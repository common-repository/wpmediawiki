<?php
/*
Plugin Name: MediaWiki Markup for WordPress
Plugin URI: http://zechs.dyndns.org/wordpress/?page_id=126
Description: Add a subset of MediaWiki markups to WordPress
Version: 0.0.8
Author: Ming-Hsien Tsai
Author URI: http://zechs.dyndns.org/wordpress/
*/

/*  Copyright 2006  Ming-Hsien Tsai  (email : mhtsai208@gmail.com)

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

class WikiText {

  const LIST_TYPE_OL = "#";
  const LIST_TYPE_UL = "*";
  const LIST_TYPE_INDENT = ":";
  const LIST_TYPE_DEFINITION = ";";

  private $headings = array(); // all headings in the post
  private $id_suffix = array(); // the suffix to be appended after IDs of duplicate headings
  private static $option_names = array( // option names
    'wpwiki_wiki_site',
    'wpwiki_error_page',
    'wpwiki_add_prefix_for_id',
    'wpwiki_toc_mode',
    'wpwiki_toc_title',
    'wpwiki_url_backward',
    'wpwiki_hr_tag',
    'wpwiki_disable_preformatted',
    'wpwiki_disable_horizontal',
    'wpwiki_disable_headings',
    'wpwiki_disable_lists',
    'wpwiki_disable_tables',
    'wpwiki_disable_external_links',
    'wpwiki_disable_wikilinks',
    'wpwiki_disable_emphasis'
  );
  private $options = array(); // options
  private $auto_number = 0; // the counter used in anonymous external links
  private $table_level = 0;
  private $pagenum = 1; // the page number of a multipaged post
  private $list_stack = array();
  private $rmap = array();
  private $rules = array();
  private $regex = array ( // the regular expressions of all rules
    'newline' => array ('/(\r\n|\r)/', 'newline_callback'),
    'encode' => array ('/.*/sm', 'encode'),
    'horizontal' => array ('/^----$/m', 'horizontal_callback'),
    'headings' => array ('/^(={1,6})(.*?)\1(?:\s|$)$/m', 'heading_callback'),
    'lists' => array ('/\n((?:\*|#|\;|\:)+.*?\n(?!(?:\*|#|\;|\:)+))/s', 'list_callback'),
    'preformatted' => array ('/((\n .*)+)/', 'preformatted_callback'),
    'tables' => array ('#^\{\|(.*?)(?:^\|\+(.*?))?(^(?:((?R))|.)*?)^\|}#msi', 'table_callback'),
    'external_links' => array ("/(\[)?((http\:\/\/|https\:\/\/|ftp\:\/\/|gopher\:\/\/|news\:\/\/)[\w|\d|\.|_|\-]+[A-Za-z0-9\/?=&%~_\-\.\:#;',]*)(?(1)([ ]+[^\]]+)?\])/i", 'url_callback'),
    'email' => array ('/(\[)?mailto:([\w|\d|\.|_|\-]+@[\w|\d|\.|_|-]+)(?(1)\])/i', 'email_callback'),
    'wikilinks' => array ('/\[{2}([^\||^\]|^\[]+)(?:\|([^\||^\[|^\]]+))?\]{2}/', 'wikilink_callback'),
    'emphasis' => array ("/(?<!')'('{1,4})(.*?)\\1'(?!')/", 'emphasis_callback'),
//    'paragraph' => array ("/^(.*)\n\n+/Ums", 'paragraph_callback'),
    'decode' => array ('/.*/sm', 'decode'),
    'raw' => array ('/<pre>(.*)<\/pre>/Ums', 'raw_callback'),
    'nowiki' => array ('/<nowiki>|<\/nowiki>/i', 'nowiki_callback')
  );

  /**
   * The constructor
   */     
  public function WikiText() {

    // update options
    foreach (self::$option_names as $op)
      $this->options[$op] = get_option($op);
    if (empty($this->options['wpwiki_toc_title']))
      $this->options['wpwiki_toc_title'] = 'Table of Content';

    // update rules
    foreach (array_keys($this->regex) as $rule)
      $this->options['wpwiki_disable_'.$rule] || $this->rules[] = $rule;

    // calculate rmap
    $this->rmap = array (
      '[' => md5('['),   ']' => md5(']'), 
      '<' => md5('<'),   '>' => md5('>'), 
      ':' => md5(':'),   '/' => md5('/'),
      '=' => md5('='),   '*' => md5('*'),
      '#' => md5('#'),   ';' => md5(';'),
      "'" => md5("'"),   '|' => md5('|'),
      '!' => md5('!'),   '-' => md5('-'),
      "\n" => md5("\n"), ' ' => md5(' ')
    );
  }

  /**
   * Remove the leading space in the url generated by <!--more-->
   */     
  private function fix($text) {
    global $id;

    $more = '<a href="'.get_permalink().'#more-'.$id.'"';
    return str_replace(" $more", $more, $text);
  }

  /**
   * Translate MediaWiki markups
   */     
  public function transform($text) {
    global $comment, $page, $pages, $multipage;

    $ret = $this->fix($text);

    // process rules

    foreach ($this->rules as $rule) {
      $pattern = $this->regex[$rule][0];
      $callback = $this->regex[$rule][1];
      $ret = preg_replace_callback($pattern, array($this, $callback), $ret);
    }

    // gather all headings in multipaged posts
    if (in_array('headings', $this->rules) && $multipage) {
      $this->headings = array();
      foreach ($pages as $p) {
        $this->id_suffix = array();
        preg_replace_callback($this->regex['headings'][0], array ($this, $this->regex['headings'][1]), $this->encode(array($p)));
        $this->pagenum++;
      }
    }

    // display toc in a single post or page
    if (empty($comment)) {
      if ($this->options['wpwiki_toc_mode'] == 'single' && $page == 1)
        $ret = $this->generate_toc().$ret;
      else if ($this->options['wpwiki_toc_mode'] == 'tag')
        $ret = preg_replace('/<!--toc-->/Umsi', $this->generate_toc(), $ret);
    }

    return $ret;
  }

  /**
   * Get option names
   */   
  public static function get_option_names() {
    return self::$option_names;
  }

  /**
   * Remove the leading char of a string
   */     
  private function remove_leading_char($str) {
    return substr($str, 1);
  }
  
  /**
   * Generate table of content
   */     
  private function generate_toc() {

    if (empty($this->headings))
      return;

    $ret = "<div>
      <table id='_toc' class='toc' summary='toc'>
      <tr><td id='_tochead'><span id='_toctitle'>".$this->options['wpwiki_toc_title']."</span> [<a href='javascript:toggle_toc()'><span id='_toctoggle'>Hide</span></a>]</td></tr>
      <tr><td><div id='_toclist' class='toclist'>";
  
    $min = $this->headings[0]['level'];
    $level = array();
    $prev = 0;
    foreach ($this->headings as $k => $h) {
      $depth = $h['level'] - $min + 1;
      $depth = $depth < 1 ? 1 : $depth;

      if ($depth > $prev) { // add one level
        $toclevel = count($level) + 1;
        $ret .= "<ul>\n<li class='toclevel-$toclevel'>";
        $open = true;
        array_push($level, 1);
      }
      else if ($depth == $prev || $depth >= count($level)) { // no change
        $toclevel = count($level);
        $ret .= "</li>\n<li class='toclevel-$toclevel'>";
        $level[count($level) - 1] = ++$level[count($level) - 1];
      }
      else {
        $toclevel = $depth;
        while(count($level) > $depth) {
          $ret .= "</li>\n</ul>";
          array_pop($level);
        }
        $level[count($level) - 1] = ++$level[count($level) - 1];
        $ret .= "</li>\n<li class='toclevel-$toclevel'>";
      }
      $prev = $depth;

      $ret .= "<a href='".$h['link']."'><span class='tocnumber'>".implode('.', $level)."</span> <span class='toctext'>".$h['text']."</span></a>";
    }
    
    // close left
    while(count($level) > 0) {
      $ret .= "</li></ul>";
      array_pop($level);
    }    
    $ret .= "</div></td></tr></table></div>\n";
    
    return $ret;
  }

  /**
   * Convert illegal chars in an ID
   */
  private function sanitize_id($id) {
    $ret = str_replace(' ', '_', $id);
    $ret = str_replace('%', '.', rawurlencode($ret));
    $ret = $this->options['wpwiki_add_prefix_for_id'] ? '_'.$ret : $ret;
    return $ret;
  }

  /**
   * Get the post object from a post title
   */     
  private function get_post_from_title($title) {
    global $wpdb;

    $id = $wpdb->get_var("SELECT ID FROM $wpdb->posts WHERE post_title = '".addslashes($title)."' LIMIT 1");
		if ($id)
			return get_post($id);
		else
			return null;
  }

  /**
   * Return the open tag of a list
   */
  private function open_list($type) {
    $ret = "";

    switch ($type) {
      case self::LIST_TYPE_UL:
        $ret = "<ul>";
        break;
      case self::LIST_TYPE_OL:
        $ret = "<ol>";
        break;
      case self::LIST_TYPE_DEFINITION:
      case self::LIST_TYPE_INDENT:
        $ret = "<dl>";
        break;
    }
    
    return $ret;
  }

  /**
   * Return the closing tag of a list
   */
  private function close_list($type) {
    $ret = "";

    switch ($type) {
      case self::LIST_TYPE_UL:
        $ret = "</ul>";
        break;
      case self::LIST_TYPE_OL:
        $ret = "</ol>";
        break;
      case self::LIST_TYPE_DEFINITION:
      case self::LIST_TYPE_INDENT:
        $ret = "</dl>";
        break;
    }
    return $ret;
  }

  /**
   * Return the open tag for list item
   */     
  private function open_list_item($type) {
    $ret = "";

    switch ($type) {
      case self::LIST_TYPE_UL:
      case self::LIST_TYPE_OL:
        $ret = "<li>";
        break;
      case self::LIST_TYPE_DEFINITION:
        $ret = "<dt>";
        break;
      case self::LIST_TYPE_INDENT:
        $ret = "<dd>";
        break;
    }

    return $ret;
  }

  /**
   * Return the closing tag for list item
   */
  private function close_list_item($type) {
    $ret = "";

    switch ($type) {
      case self::LIST_TYPE_UL:
      case self::LIST_TYPE_OL:
        $ret = "\n</li>";
        break;
      case self::LIST_TYPE_DEFINITION:
        $ret = "\n</dt>";
        break;
      case self::LIST_TYPE_INDENT:
        $ret = "\n</dd>";
        break;
    }

    return $ret;
  }

  /**
   * Check whether the type of two lists are the same
   */     
  private function list_type_eq($t1, $t2) {
    $ret = false;
    switch ($t1.$t2) {
      case self::LIST_TYPE_UL.self::LIST_TYPE_UL:
      case self::LIST_TYPE_OL.self::LIST_TYPE_OL:
      case self::LIST_TYPE_DEFINITION.self::LIST_TYPE_DEFINITION:
      case self::LIST_TYPE_DEFINITION.self::LIST_TYPE_INDENT:
      case self::LIST_TYPE_INDENT.self::LIST_TYPE_INDENT:
      case self::LIST_TYPE_INDENT.self::LIST_TYPE_DEFINITION:
        $ret = true;
        break;
    }
    return $ret;
  }

  /**
   * Encode special chars in <pre>, <nowiki>, <a> and <img>
   */
  private function encode($matches) {
    if ($this->options['wpwiki_url_backward'])
      $pattern = '/<(pre|nowiki)>.*<\/\1>|<a\s+[^>]*>(.*)<\/a>|<img\s+[^>]*\/>/Ums';
    else
      $pattern = '/<(pre|nowiki)>.*<\/\1>/Ums';
    return preg_replace_callback($pattern, array($this, 'encode_callback'), $matches[0]);
  }

  /**
   * Decode special chars in <pre>, <nowiki>, <a> and <img>
   */
  private function decode($matches) {
    $pattern = '/'.md5('[').'(.*)'.md5(']').'/Ums';
    return preg_replace_callback($pattern, array($this, 'decode_callback'), $matches[0]);
  }

  /**
   * The callback function for encode
   */     
  private function encode_callback($matches) {
    $ret = str_replace(array('%', '-'), array(md5('%'), md5('-')), $matches[0]);
    $ret = rawurlencode($ret);
    $ret = md5('[').$ret.md5(']');
    if ($matches[1] == 'pre')
      $ret = "\n".$ret;

    return $ret;
  }

  /**
   * The callback function for decode
   */     
  private function decode_callback($matches) {      
    $ret = rawurldecode($matches[1]);
    $ret = str_replace(array(md5('%'), md5('-')), array('%', '-'), $ret);

    return $ret;
  }

  /**
   * Replace all continuous newlines to one "\n"
   */     
  private function newline_callback($matches) {
    return "\n";
  }

  /**
   * Convert HTML special cahrs in <pre>
   */     
  function raw_callback($matches) {
    $text = htmlspecialchars(htmlspecialchars_decode($matches[1]));
    $ret = "<pre>$text</pre>";
    return $ret;
  }

  /**
   * The callback function for horizontal line
   */     
  private function horizontal_callback($matches) {
    $ret = $this->options['wpwiki_hr_tag'];
    $ret || $ret = '<hr/>'; 
    return $ret;
  }

  /**
   * The callback function for headings
   */     
  private function heading_callback($matches) {
    global $post;

    $level = strlen($matches[1]);
    $text = trim($matches[2]);

    if (is_single() || is_page()) {
      $suffix = '';
      if (array_key_exists($text, $this->id_suffix)) {
        $this->id_suffix[$text]++; 
        $suffix = '_'.$this->id_suffix[$text]; 
      }
      else { 
        $this->id_suffix[$text] = 1;
      }
      $id = $this->sanitize_id($text).$suffix;

      $ret = "<h{$level} id=\"$id\">{$text}</h{$level}>";

      $link = $this->append_pagenum_anchor(get_permalink($post->ID), $this->pagenum, $id);
      
      $this->headings[] = array (
        'level' => $level,
        'link' => $link,
        'text' => $text
      );
    }
    else
      $ret = "<h{$level}>{$text}</h{$level}>";
    
    return $ret;
  }

  /**
   * The callback function for lists
   */     
  private function list_callback($matches) {
    $list = array();
    $prev = "";
    $ret = "";

    preg_match_all('/^((\*|#|\;|\:|\^)+)(.*?)$/ms', $matches[1], $list, PREG_SET_ORDER);
    foreach ($list as $val) {
      $whole = $val[0];
      $type = $val[1];
      $last_type = $val[2];
      $text = $val[3];
      if (substr($text, 0, 1) == " ")
      	$text = substr($text, 1);
      		
      $size = strlen($type);

      // same list level
      if ($type == $prev) {
        $ret .= $this->close_list_item($last_type).$this->open_list_item($last_type).$text;
      }
      // a continuation of previous list item
      else if ($type == $prev."^") {
      	$ret .= "\n".$text;
      }
      else {
        // different list level
        $prev_size = strlen($prev);
        $min_size = min($size, $prev_size);

        // max common prefix 
        $index = 0;
        while ($this->list_type_eq($type[$index], $prev[$index]) && $index < $min_size)
          $index++;

        // close previous non-common suffix
        while(count($this->list_stack) > $index) {
          $close_tag = array_pop($this->list_stack);
          $ret .= $this->close_list_item($close_tag).$this->close_list($close_tag);
        }

        // open current non-common suffix
        $open = false;
        for ($i = $index; $i < $size; $i++) {
          $open_tag = $type[$i];
          array_push($this->list_stack, $open_tag);
          $open = true;
          $ret .= $this->open_list($open_tag).$this->open_list_item($open_tag);
        }
        if (!$open) {
          $close_tag = $prev[$index - 1];
          $open_tag = $type[$index - 1];
          // exchange stack item
          array_pop($this->list_stack);
          array_push($this->list_stack, $open_tag);
          $ret .= $this->close_list_item($close_tag).$this->open_list_item($open_tag);
        }

        $ret .= $text;

        $prev = $type;
      }
    }
    
    // close remainder
    while (count($this->list_stack) > 0) {
      $close_tag = array_pop($this->list_stack);
      $ret .= $this->close_list_item($close_tag).$this->close_list($close_tag);
    }

    return "\n".$ret."\n";
  }

  /**
   * The callback function for tables
   */     
  private function table_callback($matches) {
    $whole = $matches[0];
    $attrs = trim($matches[1]);
    $rows = $matches[3];

    if (array_key_exists(4, $matches)) {
      $this->table_level += 3;
      $rows = preg_replace_callback($this->regex['table'][0], array($this, $this->regex['table'][1]), $rows);
      $this->table_level -= 3;
    }

    $rregex = '#(?:^(\||!)-|\G)(.*?)^(.*?)(?=(?:\|-|!-|\z))#msi';
    $rows = preg_replace_callback($rregex, array($this, 'rows_callback'), $rows);

    $start = $attrs == "" ? "<table>" : "<table {$attrs}>";
    $end = "</table>";


//    $ret =
//      str_repeat("\t", $this->table_level).$start."\n".
//      $rows.
//      str_repeat("\t", $this->table_level).$end."\n";
    $ret = $start."\n".$rows.$end."\n";
    
    return $ret;
  }

  /**
   * The callback function for rows in tables
   */       
  private function rows_callback($matches) {
    $whole = $matches[0];
    $attrs = trim($matches[2]);
    $cells = $matches[3];
    
    if ($whole == "")
      return $whole;

    $cregex = '#((?:\||!|\|\||!!|\G))(?:([^|\n]*?)\|(?!\|))?(.+?)(?=\||!|\|\||!!|\z)#msi';
    $cells = preg_replace_callback($cregex, array(&$this, 'cells_callback'), $cells);
    
    $start = $attrs == "" ? "<tr>" : "<tr {$attrs}>";
    $end = "</tr>";

//    $ret =
//      str_repeat("\t", $this->table_level + 1).$start."\n".
//      $cells.
//      str_repeat("\t", $this->table_level + 1).$end."\n";
    $ret = $start."\n".$cells.$end."\n";
    
    return $ret;
  }

  /**
   * The callback function for cols in rows
   */     
  private function cells_callback($matches) {
    $whole = $matches[0];
    $type = $matches[1];
    $attrs = trim($matches[2]);
    $cell = trim($matches[3]);
    
    if($whole == "")
      return $whole;

    if ($type == '!') {
      $start = $attrs == "" ? "<th>" : "<th {$attrs}>";
      $end = "</th>";
    }
    else {
      $start = $attrs == "" ? "<td>" : "<td {$attrs}>";
      $end = "</td>";
    }

//    $ret = 
//      str_repeat("\t", $this->table_level + 2).$start."\n".
//      str_repeat("\t", $this->table_level + 3).$cell."\n".
//      str_repeat("\t", $this->table_level + 2).$end."\n";
    $ret = $start."\n".$cell."\n".$end."\n";
    
    return $ret;
  }

  /**
   * The callback function for external links
   */     
  private function url_callback($matches) {
    $whole = $matches[0];
    $explicit = $matches[1]; // a left "["
    $url = $matches[2]; // url
    $protocol = $matches[3]; // protocol, eq: http://
    $desc = $matches[4]; // url description
    
    if (!isset($desc)) {
      if($explicit)
        $desc = "[".$this->auto_number++."]";
      else
        $desc = $url;
    }
    $desc = trim($desc);
    $ret = "<a href=\"{$url}\">{$desc}</a>";
    
    return $ret;
  }

  /**
   * The callback function for email links
   */     
  private function email_callback($matches) {
    $whole = $matches[0];
    $addr = $matches[2];
    
    $ret = "<a href=\"mailto:{$addr}\">$addr</a>";
    
    return $ret;
  }

  /**
   * Split anchor into the anchor text and the index of the anchor
   */     
  private function split_anchor($anchor) {
    $index = strrpos($anchor, '_');

    // get the anchor text and anchor index
    if ($index != false && $index < strlen($anchor) && is_numeric(substr($anchor, $index + 1))) {
      $anchor_txt = substr($anchor, 0, $index);
      $anchor_num = substr($anchor, $index + 1);
    }
    else {
      $anchor_txt = $anchor;
      $anchor_num = 1;
    }
    
    return array ($anchor_txt, $anchor_num);
  }

  /**
   * Append page number and anchor to an url to form a valid url
   */     
  private function append_pagenum_anchor($url, $pagenum = 0, $anchor = '') {
    $anchor = $anchor ? '#'.$anchor : $anchor;
    if ($pagenum > 1)
      $url .= (strpos($url, '?') ? '&' : '?').'page='.$pagenum;
    $url .= $anchor;
    return $url;
  }

  private function is_toc_id($id) {
    switch ($id) {
      case "_toc":
      case "_tochead":
      case "_toctoggle":
      case "_toclist":
        $ret = true; break;
      default:
        $ret = false; break;
    }
    return $ret;
  }

  /**
   * The callback function for wikilinks
   */     
  private function wikilink_callback($matches) {
    global $wpdb, $post, $pages;

    // $link: $title#$anchor
    // $title: the post title
    // $anchor: the user defined anchor or some heading
    // $desc: the displayed text
    $while = $matches[0];
    $link = $matches[1];
    $desc = $matches[2];
    list($title, $anchor) = split('#', $link);    

    // set desc if desc is empty
    $desc = $desc ? $desc : $link;

    // compute url
    if ($title && $this->options['wpwiki_wiki_site']) {
      $url = $this->options['wpwiki_wiki_site'].$title.($anchor ? '#'.$anchor : $anchor);
    }
    else {
      // get the post nad post url
      if ($title) // link to other post
        $the_post = $this->get_post_from_title($title);
      else // link to this post
        $the_post = $post;
      
      if ($the_post == null) {
      	$url = $this->options['wpwiki_error_page'];
      }
      else {
      	$url = get_permalink($the_post->ID);
				echo "URL = ".$url;
      	// append anchor to url
      	if ($anchor) {
	        // find anchor from headings
  	      $pagenum = 1;

        	// determine the pages of the post
        	if ($this->is_toc_id($anchor)) {
	          $url .= '#'.$anchor;
        	}
        	else {
	          $tmp = preg_replace_callback($this->regex['preformatted'][0], array($this, $this->regex['preformatted'][1]), $the_post->post_content);
          	$the_pages = explode('<!--nextpage-->', $this->encode(array($tmp)));
          	list($anchor_txt, $anchor_num) = $this->split_anchor($anchor);

	          foreach ($the_pages as $p) {
            	// match headings
            	$index = preg_match_all('/^(={1,6})\s*'.preg_quote($anchor_txt).'\s*\1(?:\s*|$)$/m', $p, $tmp);
            	if ($index >= $anchor_num) {
	              $anchor = $this->sanitize_id($anchor_num > 1 ? $anchor_txt.'_'.$anchor_num : $anchor_txt);
              	break;
            	}
            	else if (preg_match('/id="'.preg_quote($anchor).'"/', $p)) { // match user defined id
	              break;
            	}
            	$anchor_num -= $index;
            	$pagenum++;
          	}

          	if ($pagenum <= count($the_pages))        
	            $url = $this->append_pagenum_anchor($url, $pagenum, $anchor);
        	}
      	}
    	}
    }

    $ret = "<a href=\"{$url}\">{$desc}</a>";

    return $ret;
  }

  /**
   * The callback function for bold and italic
   */     
  private function emphasis_callback($matches) {
    $type = $matches[1];
    $text = $matches[2];

    switch (strlen($type)) {
      case 1:
        $ret = "<em>{$text}</em>";
        break;
      case 2:
        $ret = "<strong>{$text}</strong>";
        break;
      case 4:
        $ret = "<em><strong>{$text}</strong></em>";
        break;
      case 3:
        $delim = "'";
        $ret = "<strong>{$delim}{$text}{$delim}</strong>";
        break;
    }
    
    return $ret;
  }

  private function paragraph_callback($matches) {
    $text = trim($matches[1]);

    if ($text == "")
      return "";

    // skip <pre></pre>

    $regex = '/'.$this->rmap['<'].'(pre|nowiki)'.$this->rmap['>'].'(.*)'.$this->rmap['<'].$this->rmap['/'].'(\1)'.$this->rmap['>'].'/s';
    if (preg_match($regex, $text))
      return "$text\n";
    
    return "<p>\n$text\n</p>\n";;
  }

  /**
   * The callback function for nowiki. Simply return nothing
   */     
  private function nowiki_callback($matches) {
    return "";
  }

  /**
   * The callback function for preformatted text
   */     
  private function preformatted_callback($matches) {
    $ret = explode("\n", $matches[0]);
    $ret = array_map(array($this, 'remove_leading_char'), $ret);
    $ret = implode("\n", $ret);
    return $this->encode(array("\n<pre>$ret\n</pre>"));
  }
}

$wpwiki_options_message = "";

function wpwiki_manager() {
  global $wpwiki_options_message;

  foreach (WikiText::get_option_names() as $op)
    $$op = get_option($op);
  
  if ($wpwiki_options_message) {
    ?>
    <div class="updated">
      <strong><p><?php echo $wpwiki_options_message; ?></p></strong>
    </div>
    <?php
  }

  ?>

  <div class="wrap" id="wpwiki_manager">

    <h2><?php _e('WPWiki Manager', 'wpwiki_manager'); ?></h2>

    <form name='wpwiki_options_form' action='<?php echo $_SERVER["REQUEST_URI"]; ?>' method='post'>
      <h3>Bold and Italic</h3>
      <p>
        <input class='checkbox'  type='checkbox' name='wpwiki_disable_emphasis' <?php if ($wpwiki_disable_emphasis) echo 'checked'; ?> /> Disable bold and italic.
      </p>

      <h3>Headings</h3>
      <p>
        <input class='checkbox'  type='checkbox' name='wpwiki_disable_headings' <?php if ($wpwiki_disable_headings) echo 'checked'; ?> /> Disable headings.
      </p>
      <h4>ID</h4>
      <p>
        <input class='checkbox' type='checkbox' name='wpwiki_add_prefix_for_id' <?php if ($wpwiki_add_prefix_for_id) echo 'checked'; ?> /> Add '_' as the prefix for the ID attribute of each heading.
      </p>
      <p>
        MediaWiki does not add this prefix for each ID. But if the heading does
        not start with an alphabet, the HTML document would become invalid.
        Check this option is you want a '_' to be added for the ID of each
        heading.
      </p>
      <h4>Table Of Content</h4>
      <p>
        Select how to add table of content (TOC).
        <select name='wpwiki_toc_mode'>
          <option value='none' <?php if ($wpwiki_toc_mode == 'none') echo 'selected'; ?>>None</option>
          <option value='single' <?php if ($wpwiki_toc_mode == 'single') echo 'selected'; ?>>Single</option>
          <option value='tag' <?php if ($wpwiki_toc_mode == 'tag') echo 'selected'; ?>>Tag</option>
        </select>
      </p>
      <p>
        <ul>
          <li>None: Do not display TOC.</li>
          <li>Single: Always add TOC at the top of a single post or page.</li>
          <li>Tag: Replace the tag '&lt;!--toc--&gt;' with TOC in each single post or page. You can put the tag aynwhere you like.</li>
        </ul>
      </p>
      <p>
        The displayed title of TOC
        <input type='text' name='wpwiki_toc_title' value='<? echo $wpwiki_toc_title; ?>'/>
        (Default: Table of Content)
      </p>
      <p>
        To change the style of TOC, please edit wp-mediawiki.css manually.
      </p>

      <h3>Lists</h3>
      <p>
        <input class'checkbox'  type='checkbox' name='wpwiki_disable_lists' <?php if ($wpwiki_disable_lists) echo 'checked'; ?> /> Disable lists.
      </p>

      <h3>Tables</h3>
      <p>
        <input class='checkbox'  type='checkbox' name='wpwiki_disable_tables' <?php if ($wpwiki_disable_tables) echo 'checked'; ?> /> Disable tables.
      </p>

      <h3>External Links</h3>
      <p>
        <input class='checkbox'  type='checkbox' name='wpwiki_disable_external_links' <?php if ($wpwiki_disable_external_links) echo 'checked'; ?> /> Disable external links.
      </p>
      <p>
        <input class='checkbox' type='checkbox' name='wpwiki_url_backward' <?php if ($wpwiki_url_backward) echo 'checked'; ?> /> URL compatibility
      </p>
      <p>
        MediaWiki converts external links in &lt;a&gt; and &lt;img&gt;. Check this if
        you do not want to convert external links in &lt;a&gt; and &lt;img/&gt;
        by this plugin.
      </pre>

      <h3>WikiLinks</h3>
      <p>
        <input class='checkbox'  type='checkbox' name='wpwiki_disable_wikilinks' <?php if ($wpwiki_disable_wikilinks) echo 'checked'; ?> /> Disable wikilinks.
      </p>
      <p>
        Base wiki site <input type='text' size='50' name='wpwiki_wiki_site' value='<?php echo $wpwiki_wiki_site; ?>' />
      </p>
      <p>
        The wiki link [[article_title|description]] will create a hyperlink to
        the article with title "article_title" in the base wiki site. If you leave
        this option empty, the base wiki site will be your blog site by default.
        You may want to change this to "http://en.wikipedia.org/wiki/" or other
        wiki sites.
      </p>
      <p>
        Error page <input type='text' size='50' name='wpwiki_error_page' value='<?php echo $wpwiki_error_page; ?>' />
      </p>
      <p>
        When the plugin cannot find the page of the wiki link, open this error page.
      </p>

      <h3>Preformatted Text</h3>
      <p>
        <input class='checkbox'  type='checkbox' name='wpwiki_disable_preformatted' <?php if ($wpwiki_disable_preformatted) echo 'checked'; ?> /> Disable preformatted text.
      </p>

      <h3>Horizontal Line</h3>
      <p>
        <input class='checkbox'  type='checkbox' name='wpwiki_disable_horizontal' <?php if ($wpwiki_disable_horizontal) echo 'checked'; ?> /> Disable horizontal line.
      </p>
      <p>
        The tag for creating horizontal line:
        <input type='text' name='wpwiki_hr_tag' value='<?php echo htmlspecialchars(stripslashes($wpwiki_hr_tag), ENT_QUOTES); ?>'/>
        (Default: &lt;hr/&gt;)
      </p>
      <p>
        In some themes, the style of "&lt;hr/&gt;" may be "display: none" and thus
        the horizontal line will not be displayed. You may want to use another tag,
        for example "&lt;div class='hr'&gt;&lt;hr/&gt;&lt;/div&gt;", and add the
        following to CSS.
        <pre>
          div.hr hr {
            display: block;
          }
        </pre>
      </p>
      <input type='hidden' name='action' value='save_wpwiki_options' />
      <div class='submit'><input type='submit' value='Save Options' /></div>
    </form>

  </div>

  <?php
}

if ($_POST['action'] == 'save_wpwiki_options') {
  foreach (WikiText::get_option_names() as $op)  
    update_option($op, $_POST[$op]);
  update_option('wpwiki_hr_tag', htmlspecialchars_decode(stripslashes($_POST['wpwiki_hr_tag'])));

  $wpwiki_options_message .= "Successfully updated.";
}
  
function wpwiki_add_options_page() {
  add_options_page('MediaWiki Markup for WordPress', 'WPWiki', 5, __FILE__, 'wpwiki_manager');
}

function wpwiki_add_css_and_js() {
  include_once('wp-mediawiki'.DIRECTORY_SEPARATOR.'wp-mediawiki.css');
  include_once('wp-mediawiki'.DIRECTORY_SEPARATOR.'wp-mediawiki.js');
}

function wpwiki($content) {
  $wpwiki = new WikiText();
  $ret = $wpwiki->transform("\n".$content."\n");

  return $ret;
}

//remove_filter('the_content', 'wpautop');
//remove_filter('the_excerpt', 'wpautop');
//remove_filter('comment_text', 'wpautop');
remove_filter('comment_text', 'make_clickable');

add_filter('the_content', 'wpwiki', 5);
add_filter('the_content_rss', 'wpwiki', 5);
add_filter('the_excerpt', 'wpwiki', 5);
add_filter('the_excerpt_rss', 'wpwiki', 5);
add_filter('comment_text', 'wpwiki', 5);

add_action('wp_head', 'wpwiki_add_css_and_js');  
add_action('admin_menu', 'wpwiki_add_options_page');

?>
